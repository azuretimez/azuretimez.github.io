(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{619:function(t,e,a){"use strict";a.r(e);var r=a(6),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#核心概念"}},[t._v("核心概念")])])])]),a("p"),t._v(" "),a("h1",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" redux")]),t._v(" "),a("ul",[a("li",[t._v("Redux 是一个独立的 JavaScript 状态管理库，不依赖于任何其他库")]),t._v(" "),a("li",[t._v("https://www.redux.org.cn/")])]),t._v(" "),a("h1",{attrs:{id:"安装-redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装-redux"}},[t._v("#")]),t._v(" 安装 Redux")]),t._v(" "),a("p",[t._v("npm i redux\nyarn add redux")]),t._v(" "),a("h3",{attrs:{id:"核心概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心概念"}},[t._v("#")]),t._v(" 核心概念")]),t._v(" "),a("p",[t._v("理解 Redux 核心几个概念与它们之间的关系")]),t._v(" "),a("ul",[a("li",[t._v("state 状态")]),t._v(" "),a("li",[t._v("reducer 纯函数 - 提供修改状态的方法")]),t._v(" "),a("li",[t._v("store 仓库 - 管理状态")]),t._v(" "),a("li",[t._v("action 动作 - 对 state 的修改动作")])]),t._v(" "),a("h4",{attrs:{id:"state-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-对象"}},[t._v("#")]),t._v(" state 对象")]),t._v(" "),a("p",[t._v("通常我们会把应用中的数据存储到一个对象树（Object Tree） 中进行统一管理，我们把这个对象树称为：state")]),t._v(" "),a("h5",{attrs:{id:"state-是只读的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-是只读的"}},[t._v("#")]),t._v(" state 是只读的")]),t._v(" "),a("p",[t._v("这里需要注意的是，为了保证数据状态的可维护和测试，不推荐直接修改 state 中的原数据")]),t._v(" "),a("h5",{attrs:{id:"通过纯函数修改-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过纯函数修改-state"}},[t._v("#")]),t._v(" 通过纯函数修改 state")]),t._v(" "),a("p",[t._v("什么是纯函数？")]),t._v(" "),a("h6",{attrs:{id:"纯函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#纯函数"}},[t._v("#")]),t._v(" 纯函数")]),t._v(" "),a("ol",[a("li",[t._v("相同的输入永远返回相同的输出")]),t._v(" "),a("li",[t._v("不修改函数的输入值")]),t._v(" "),a("li",[t._v("不依赖外部环境状态，只依赖其参数")]),t._v(" "),a("li",[t._v("无任何副作用")])]),t._v(" "),a("p",[t._v("使用纯函数的好处")]),t._v(" "),a("ol",[a("li",[t._v("便于测试")]),t._v(" "),a("li",[t._v("有利重构")])]),t._v(" "),a("h4",{attrs:{id:"action-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#action-对象"}},[t._v("#")]),t._v(" action 对象")]),t._v(" "),a("p",[t._v("我们对 state 的修改是通过 reducer 纯函数来进行的，同时通过传入的 action 来执行具体的操作，action 是一个对象")]),t._v(" "),a("ul",[a("li",[t._v("type 属性 : 表示要进行操作的动作类型，增删改查……")]),t._v(" "),a("li",[t._v("payload属性 : 操作 state 的同时传入的数据")])]),t._v(" "),a("p",[t._v("但是这里需要注意的是，我们不直接去调用 Reducer 函数，而是通过 Store 对象提供的 dispatch 方法来调用")]),t._v(" "),a("h4",{attrs:{id:"store-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#store-对象"}},[t._v("#")]),t._v(" Store 对象")]),t._v(" "),a("p",[t._v("为了对 state，Reducer，action 进行统一管理和维护，我们需要创建一个 Store 对象")]),t._v(" "),a("h2",{attrs:{id:"redux-三大原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux-三大原则"}},[t._v("#")]),t._v(" redux 三大原则")]),t._v(" "),a("ul",[a("li",[t._v("单一数据源: 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中")]),t._v(" "),a("li",[t._v("state 是只读的: 唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象")]),t._v(" "),a("li",[t._v("使用纯函数来执行修改")])]),t._v(" "),a("h2",{attrs:{id:"redux-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux-api"}},[t._v("#")]),t._v(" redux API")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("createStore(reducer, [preloadedState], enhancer);")]),t._v(" "),a("ul",[a("li",[t._v("reducer (Function): 接收两个参数，分别是当前的 state 树和要处理的 action，返回新的 state 树。")]),t._v(" "),a("li",[t._v("[preloadedState] (any): 初始时的 state。 在同构应用中，你可以决定是否把服务端传来的 state 后传给它，或者从之前保存的用户会话中恢复一个传给它。如果你使用 combineReducers 创建 - reducer，它必须是一个普通对象，与传入的 keys 保持同样的结构。否则，你可以自由传入任何 reducer 可理解的内容。")]),t._v(" "),a("li",[t._v("enhancer (Function): Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。")]),t._v(" "),a("li",[t._v("返回值 (Store): 保存了应用所有 state 的对象。改变 state 的惟一方法是 dispatch action。你也可以 subscribe 监听 state 的变化，然后更新 UI。")])])]),t._v(" "),a("li",[a("p",[t._v("reducer")]),t._v(" "),a("ul",[a("li",[t._v("reducer(state,action)")])])]),t._v(" "),a("li",[a("p",[t._v("Store")]),t._v(" "),a("ul",[a("li",[t._v("getState()")]),t._v(" "),a("li",[t._v("dispatch(action)")]),t._v(" "),a("li",[t._v("subscribe(listener)")]),t._v(" "),a("li",[t._v("replaceReducer(nextReducer)")])])]),t._v(" "),a("li",[a("p",[t._v("combineReducers(reducers)\n将 reducer 函数拆分成多个单独的函数，拆分后的每个函数负责独立管理 state 的一部分")])]),t._v(" "),a("li",[a("p",[t._v("applyMiddleware(...middlewares) 中间件")])])]),t._v(" "),a("h2",{attrs:{id:"react-redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-redux"}},[t._v("#")]),t._v(" react-redux")]),t._v(" "),a("p",[t._v("react项目中的 redux 绑定库")]),t._v(" "),a("ul",[a("li",[t._v("安装：npm i react-redux")]),t._v(" "),a("li",[a("code",[t._v("<Provider store>")])]),t._v(" "),a("li",[t._v("connect() -- 高阶函数:传入数据，返回一个函数")]),t._v(" "),a("li",[t._v("useDispatch 获取 dispatch")]),t._v(" "),a("li",[t._v("useStore 获取 store")]),t._v(" "),a("li",[t._v("useSelector 获取 state")])]),t._v(" "),a("h2",{attrs:{id:"中间件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#中间件"}},[t._v("#")]),t._v(" 中间件")]),t._v(" "),a("p",[t._v("更新的过程中，去做一些其他的事情，\ndispatch ---\x3e reducer 更新state\ndispatch --\x3e 中间件 --\x3e reducer")]),t._v(" "),a("h2",{attrs:{id:"异步操作中间件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步操作中间件"}},[t._v("#")]),t._v(" 异步操作中间件")]),t._v(" "),a("ul",[a("li",[t._v("redux-thunk\n"),a("ul",[a("li",[t._v("参数是对象，直接调用 reducer 修改我们的 state")]),t._v(" "),a("li",[t._v("参数是函数，调用该函数，并且把 dispatch 和 getState 传递我们的函数，可以在函数中，进行异步操作")])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);