(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{614:function(t,e,a){"use strict";a.r(e);var s=a(6),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#state-和-setstate"}},[t._v("state 和 setState")])]),a("li",[a("a",{attrs:{href:"#组件间通信"}},[t._v("组件间通信")])]),a("li",[a("a",{attrs:{href:"#受控组件"}},[t._v("受控组件")])]),a("li",[a("a",{attrs:{href:"#组件的生命周期"}},[t._v("组件的生命周期")])])])]),a("p"),t._v(" "),a("h3",{attrs:{id:"state-和-setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-和-setstate"}},[t._v("#")]),t._v(" state 和 setState")]),t._v(" "),a("ul",[a("li",[t._v("setState(updater, [callback])\n"),a("ul",[a("li",[t._v("updater: 更新数据 FUNCTION/OBJECT")]),t._v(" "),a("li",[t._v("callback: 更新成功后的回调 FUNCTION")]),t._v(" "),a("li",[t._v("异步: react通常会集齐一批需要更新的组件，然后一次性更新来保证渲染的性能")]),t._v(" "),a("li",[t._v("浅合并 Objecr.assign()")]),t._v(" "),a("li",[t._v("调用 setState 之后，会触发生命周期，重新渲染组件")])])])]),t._v(" "),a("h3",{attrs:{id:"组件间通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件间通信"}},[t._v("#")]),t._v(" 组件间通信")]),t._v(" "),a("p",[t._v("在 React.js 中，数据是从上自下流动（传递）的，也就是一个父组件可以把它的 state / props 通过 props 传递给它的子组件，但是子组件不能修改 props - React.js 是单向数据流，如果子组件需要修改父组件状态（数据），是通过回调函数方式来完成的。")]),t._v(" "),a("ul",[a("li",[t._v("父级向子级通信\n把数据添加子组件的属性中，然后子组件中从props属性中，获取父级传递过来的数据")]),t._v(" "),a("li",[t._v("子级向父级通信\n在父级中定义相关的数据操作方法(或其他回调), 把该方法传递给子级，在子级中调用该方法父级传递消息")]),t._v(" "),a("li",[t._v("案例：完善好友列表")])]),t._v(" "),a("h4",{attrs:{id:"跨组件通信-context-扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨组件通信-context-扩展"}},[t._v("#")]),t._v(" 跨组件通信 context - 扩展")]),t._v(" "),a("ul",[a("li",[t._v("React.createContext(defaultValue);\n{ Consumer, Provider } = createContext(defaultValue)")]),t._v(" "),a("li",[t._v("Context.Provider 在父组件调用 Provider 传递数据\n"),a("ul",[a("li",[t._v("value 要传递的数据")])])]),t._v(" "),a("li",[t._v("接收数据\n"),a("ul",[a("li",[t._v("class.contextType = Context;")]),t._v(" "),a("li",[t._v("static contextType = Context;\n"),a("ul",[a("li",[t._v("this.context;")])])]),t._v(" "),a("li",[t._v("Context.Consumer\n"),a("code",[t._v("<Consumer> {(props)=>{ console.log(props); return <div></div> }} </Consumer>")]),t._v(" "),a("strong",[t._v("注意在使用不熟练时，最好不要在项目中使用 context，context一般给第三方库使用")])])])])]),t._v(" "),a("h3",{attrs:{id:"受控组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#受控组件"}},[t._v("#")]),t._v(" 受控组件")]),t._v(" "),a("p",[t._v("当想要获取表单的一些内部状态时，就可以将表单的内部状态和组件的状态进行绑定，这样就形成受控组件\n受控组件: 让 表单控件 的内部状态  和我们 state 保持一致")]),t._v(" "),a("p",[t._v("非受控组件: 我们不需要同步 value 值(defaultValue，defaultChecked)")]),t._v(" "),a("h3",{attrs:{id:"组件的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件的生命周期"}},[t._v("#")]),t._v(" 组件的生命周期")]),t._v(" "),a("p",[t._v("所谓的生命周期就是指某个事物从开始到结束的各个阶段，当然在 React.js 中指的是组件从创建到销毁的过程，React.js 在这个过程中的不同阶段调用的函数，通过这些函数，我们可以更加精确的对组件进行控制，前面我们一直在使用的 render 函数其实就是组件生命周期渲染阶段执行的函数")]),t._v(" "),a("h4",{attrs:{id:"生命周期演变"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期演变"}},[t._v("#")]),t._v(" 生命周期演变")]),t._v(" "),a("ul",[a("li",[t._v("生命周期，16.3 之前，16.3, 16.4 及之后")]),t._v(" "),a("li",[t._v("挂载阶段 （组件创建--\x3e把组件创建的虚拟DOM，生成真实DOM，添加到我们的DOM树中）\n"),a("ul",[a("li",[t._v("constructor")]),t._v(" "),a("li",[t._v("static getDerivedStateFromProps(props)\n"),a("ul",[a("li",[t._v("注意 this 问题")])])]),t._v(" "),a("li",[t._v("render")]),t._v(" "),a("li",[t._v("componentDidMount -- 处理副作用(请求)")])])]),t._v(" "),a("li",[t._v("更新阶段 -- 组件重新渲染\n- static getDerivedStateFromProps(props, state)\n- shouldComponentUpdate()  -- 判断是否更新\n- render()\n- getSnapshotBeforeUpdate()\n- componentDidUpdate() -- 处理副作用(请求)")]),t._v(" "),a("li",[t._v("卸载阶段\n"),a("ul",[a("li",[t._v("componentWillUnmount  -- 删除添加在全局的一些信息或操作")])])])])])}),[],!1,null,null,null);e.default=r.exports}}]);