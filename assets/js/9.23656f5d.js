(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{525:function(t,a,s){t.exports=s.p+"assets/img/pr1.2940e42b.png"},526:function(t,a,s){t.exports=s.p+"assets/img/pr3.d91d5a9a.png"},527:function(t,a,s){t.exports=s.p+"assets/img/pr4.b2d7722b.png"},528:function(t,a,s){t.exports=s.p+"assets/img/pr5.5d06e806.png"},529:function(t,a,s){t.exports=s.p+"assets/img/pr6.8e58f187.png"},530:function(t,a,s){t.exports=s.p+"assets/img/pr7.593a7237.png"},531:function(t,a,s){t.exports=s.p+"assets/img/pr8.682f4522.png"},604:function(t,a,s){"use strict";s.r(a);var e=s(6),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#开闭原则"}},[t._v("开闭原则")])]),e("li",[e("a",{attrs:{href:"#单一职责原则"}},[t._v("单一职责原则")])]),e("li",[e("a",{attrs:{href:"#里式替换原则"}},[t._v("里式替换原则")])]),e("li",[e("a",{attrs:{href:"#依赖倒转原则"}},[t._v("依赖倒转原则")])])])]),e("p"),t._v(" "),e("h1",{attrs:{id:"面向对象设计原则概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面向对象设计原则概述"}},[t._v("#")]),t._v(" 面向对象设计原则概述")]),t._v(" "),e("p",[t._v("对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性 是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向 对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计 原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提 升一个软件结构的设计水平。")]),t._v(" "),e("p",[t._v("面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中， 它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评 价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，大家经常会看 到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的语句。")]),t._v(" "),e("p",[t._v("最常见的7种面向对象设计原则如下表所示:")]),t._v(" "),e("p",[t._v("表1 7种常用的面向对象设计原则")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("设计原则名称")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("定 义")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("使用频率")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("单一职责原则(Single Responsibility Principle, SRP)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("一个类只负责一个功能领域中 的相应职责")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("★★★★☆")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("开闭原则(Open-Closed Principle, OCP)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("软件实体应对扩展开放，而对 修改关闭")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("★★★★★")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("里氏代换原则(Liskov Substitution Principle, LSP)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("所有引用基类对象的地方能够透明地使用其子类的对象")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("★★★★★")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("依赖倒转原则(Dependence Inversion Principle, DIP)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("抽象不应该依赖于细节，细节 应该依赖于抽象")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("★★★★★")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("接口隔离原则(Interface Segregation Principle, ISP)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("使用多个专门的接口，而不使 用单一的总接口")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("★★☆☆☆")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("合成复用原则(Composite Reuse Principle, CRP)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("尽量使用对象组合，而不是继 承来达到复用的目的")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("★★★★☆")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("迪米特法则(Law of Demeter, LoD)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("一个软件实体应当尽可能少地 与其他实体发生相互作用")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("★★★☆☆")])])])]),t._v(" "),e("h1",{attrs:{id:"面向对象七大设计原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面向对象七大设计原则"}},[t._v("#")]),t._v(" 面向对象七大设计原则")]),t._v(" "),e("h2",{attrs:{id:"开闭原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[t._v("#")]),t._v(" 开闭原则")]),t._v(" "),e("p",[t._v("开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原 则。开闭原则由Bertrand Meyer于1988年提出，其定义如下:"),e("br"),t._v(" "),e("code",[t._v("1| 开闭原则(Open-Closed Principle, OCP):一个软件实体应当对扩展开放，对修改关闭。即软件实 体应尽量在不修改原有代码的情况下进行扩展。")])]),t._v(" "),e("p",[t._v("在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结 构或一个独立的类。")]),t._v(" "),e("p",[t._v("任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变 化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定 的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且 在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好 的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越 来越高，设计满足开闭原则的软件系统也变得越来越重要。")]),t._v(" "),e("p",[t._v("为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在 Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现 行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类 等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修 改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业 务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要 求。")]),t._v(" "),e("p",[t._v("示例:\nSunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等， 为了支持多种图表显示方式，原始设计方案如图1所示:")]),t._v(" "),e("p",[e("img",{attrs:{src:s(525),alt:"alt 1"}}),t._v("\n图1 初始设计方案结构图\n在ChartDisplay类的display()方法中存在如下代码片段:")]),t._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("type"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("equals")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"pie"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PieChart")]),t._v(" chart "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PieChart")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  chart"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("display")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("type"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("equals")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bar"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n  "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BarChart")]),t._v(" chart "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BarChart")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n  chart"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("display")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br")])]),e("p",[t._v("在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改 ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。")]),t._v(" "),e("p",[e("strong",[t._v("现对该系统进行重构，使之符合开闭原则。")])]),t._v(" "),e("p",[t._v("在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此 增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之 增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下:")]),t._v(" "),e("ul",[e("li",[t._v("(1) 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类;")]),t._v(" "),e("li",[t._v("(2) ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图 表。")])]),t._v(" "),e("p",[t._v("图2 重构后的结构图")]),t._v(" "),e("p",[t._v("在图2中，我们引入了抽象图表类AbstractChart，且ChartDisplay针对抽象图表类进 行编程，并通过setChart()方法由客户端来设置实例化的具体图表对象，在 ChartDisplay的display()方法中调用chart对象的display()方法显示图表。如果需要增 加一种新的图表，如折线图LineChart，只需要将LineChart也作为AbstractChart的子 类，在客户端向ChartDisplay中注入一个LineChart对象即可，无须修改现有类库的 源代码。")]),t._v(" "),e("p",[e("strong",[t._v("注意:")]),t._v(" "),e("code",[t._v("1 | 因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且 无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在 扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符 合开闭原则的系统。")])]),t._v(" "),e("h2",{attrs:{id:"单一职责原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[t._v("#")]),t._v(" 单一职责原则")]),t._v(" "),e("p",[t._v("单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责 原则定义如下:\n"),e("code",[t._v("1 | 单一职责原则(Single Responsibility Principle, SRP):一个类只负责一个功能领域中的相应 职责，或者可以定义为:就一个类而言，应该只有一个引起它变化的原因。")]),t._v("\n单一职责原则告诉我们:"),e("strong",[t._v("一个类不能太“累”")]),t._v("!在软件系统中，一个类(大到模 块，小到方法)承担的职责越多，它被复用的可能性就越小，而且一个类承担的职 责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其 他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即 将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们 封装在同一类中。")]),t._v(" "),e("p",[t._v("单一职责原则是实现"),e("strong",[t._v("高内聚、低耦合")]),t._v("的指导方针，它是最简单但又最难运用的原 则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人 员具有较强的分析设计能力和相关实践经验。")]),t._v(" "),e("p",[e("strong",[t._v("下面通过一个简单实例来进一步分析单一职责原则:")]),t._v("\nSunny软件公司开发人员针对某CRM(Customer Relationship Management，客户 关系管理)系统中客户信息图形统计模块提出了如图1所示初始设计方案:")]),t._v(" "),e("p",[e("img",{attrs:{src:s(526),alt:"alt 3"}}),t._v(" "),e("strong",[t._v("图1 初始设计方案结构图")])]),t._v(" "),e("p",[t._v("在图1中，CustomerDataChart类中的方法说明如下:")]),t._v(" "),e("ul",[e("li",[t._v("getConnection()方法用于连接数据库")]),t._v(" "),e("li",[t._v("findCustomers()用于查询所有的客户信息")]),t._v(" "),e("li",[t._v("createChart()用于创建图表")]),t._v(" "),e("li",[t._v("displayChart()用于显示图表。")])]),t._v(" "),e("p",[t._v("现使用单一职责原则对其进行重构。")]),t._v(" "),e("p",[t._v("在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法， 又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用 findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连 接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违 背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类 CustomerDataChart可拆分为如下三个类:")]),t._v(" "),e("ul",[e("li",[t._v("(1) DBUtil:负责连接数据库，包含数据库连接方法getConnection();")]),t._v(" "),e("li",[t._v("(2) CustomerDAO:负责操作数据库中的Customer表，包含对Customer表的增 删改查等方法，如findCustomers();")]),t._v(" "),e("li",[t._v("(3) CustomerDataChart:负责图表的生成和显示，包含方法createChart()和 displayChart()。")])]),t._v(" "),e("p",[t._v("使用单一职责原则重构后的结构如图2所示:\n"),e("img",{attrs:{src:s(527),alt:"alt 4"}}),t._v("\n图2 重构后的结构图")]),t._v(" "),e("h2",{attrs:{id:"里式替换原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#里式替换原则"}},[t._v("#")]),t._v(" 里式替换原则")]),t._v(" "),e("p",[t._v("里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士"),e("strong",[t._v("Barbara Liskov")]),t._v("教授和卡内基·梅隆大学Jeannette Wing教授于1994年提出。其严格表述如下:如果 对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所 有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。这个 定义比较拗口且难以理解，因此我们一般使用它的另一个通俗版定义:")]),t._v(" "),e("p",[e("code",[t._v("1 | 里氏代换原则(Liskov Substitution Principle, LSP):所有引用基类(父类)的地方必须能透 明地使用其子类的对象。")])]),t._v(" "),e("p",[t._v("里氏代换原则告诉我们，**在软件中将一个基类对象替换成它的子类对象，程序将不 会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对 象的话，那么它不一定能够使用基类对象。**例如:我喜欢动物，那我一定喜欢狗， 因为狗是动物的子类;但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢 老鼠，虽然它也是动物。")]),t._v(" "),e("p",[t._v("例如有两个类，一个类为BaseClass，另一个是SubClass类，并且 SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个 BaseClass类型的基类对象base的话，如:method1(base)，那么它 必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能 够正常运行。反过来的代换不成立，如一个方法method2接受 BaseClass类型的子类对象sub为参数:method2(sub)，那么一般而 言不可以有method2(base)，除非是重载方法。")]),t._v(" "),e("p",[t._v("里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使 用子类对象，因此"),e("strong",[t._v("在程序中尽量使用基类类型来对对象进行定义，而在运行时再确 定其子类类型，用子类对象来替换父类对象。")])]),t._v(" "),e("p",[e("strong",[t._v("在使用里氏代换原则时需要注意如下几个问题:")])]),t._v(" "),e("ul",[e("li",[t._v("(1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。 根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定 义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类 定义的对象中使用该方法。")]),t._v(" "),e("li",[t._v("(2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继 承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类 实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加 新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实 现手段之一。")]),t._v(" "),e("li",[t._v("(3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原 则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局 限的。")])]),t._v(" "),e("p",[t._v("示例:\n在Sunny软件公司开发的CRM系统中，客户(Customer)可以分为VIP客户 (VIPCustomer)和普通客户(CommonCustomer)两类，系统需要提供一个发送Email 的功能，原始设计方案如图1所示:")]),t._v(" "),e("p",[e("img",{attrs:{src:s(528),alt:"alt 5"}}),t._v("\n图5原始结构图")]),t._v(" "),e("p",[t._v("在对系统进行进一步分析后发现，无论是普通客户还是VIP客户，发送邮件的过程都 是相同的，也就是说两个send()方法中的代码重复，而且在本系统中还将增加新类型 的客户。")]),t._v(" "),e("p",[e("strong",[t._v("为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构。")])]),t._v(" "),e("p",[t._v("在本实例中，可以考虑增加一个新的抽象客户类Customer，而将 CommonCustomer和VIPCustomer类作为其子类，邮件发送类EmailSender类针对 抽象客户类Customer编程，根据里氏代换原则，能够接受基类对象的地方必然能够 接受子类对象，因此将EmailSender中的send()方法的参数类型改为Customer，如果 需要增加新类型的客户，只需将其作为Customer类的子类即可。重构后的结构如图 2所示:")]),t._v(" "),e("p",[e("img",{attrs:{src:s(529),alt:"alt 6"}})]),t._v(" "),e("p",[t._v("图2 重构后的结构图")]),t._v(" "),e("p",[e("strong",[t._v("里氏代换原则是实现开闭原则的重要方式之一。")]),t._v(" 在本实例中，在传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使 用里氏代换原则。针对基类编程，在程序运行时再确定具体子类。")]),t._v(" "),e("h2",{attrs:{id:"依赖倒转原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒转原则"}},[t._v("#")]),t._v(" 依赖倒转原则")]),t._v(" "),e("p",[t._v("如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计 的主要实现机制之一，它是系统抽象化的具体实现。依赖倒转原则是Robert C. Martin在1996年为“C++Reporter”所写的专栏Engineering Notebook的第三篇，后 来加入到他在2002年出版的经典著作“Agile Software Development, Principles, Patterns, and Practices”一书中。依赖倒转原则定义如下:")]),t._v(" "),e("p",[e("code",[t._v("1 | 依赖倒转原则(Dependency Inversion Principle, DIP):抽象不应该依赖于细节，细节应当依 赖于抽象。换言之，要针对接口编程，而不是针对实现编程。")])]),t._v(" "),e("p",[t._v("依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。")]),t._v(" "),e("p",[t._v("在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。")]),t._v(" "),e("p",[t._v("在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入 "),e("strong",[t._v("(DependencyInjection, DI)")]),t._v(" 的方式注入到其他对象中，"),e("strong",[t._v("依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。")]),t._v(" 常用的注入方式有 三种，分别是:"),e("strong",[t._v("构造注入，设值注入(Setter注入)和接口注入")]),t._v("。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。")]),t._v(" "),e("p",[t._v("下面通过一个简单实例来加深对依赖倒转原则的理解:")]),t._v(" "),e("p",[t._v("Sunny软件公司开发人员在开发某CRM系统时发现:该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类中将调用数据格式转换类的方法实现格式转换和数据库插入操作，初始设计方案结构如图1所示:")]),t._v(" "),e("p",[e("img",{attrs:{src:s(530),alt:"alt 7"}}),t._v("\n图1初始设计方案结构图")]),t._v(" "),e("p",[t._v("在编码实现图1所示结构时，Sunny软件公司开发人员发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时候需要将TXTDataConvertor改为ExcelDataConvertor，此时，需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违反了开闭原则，现需要对该方案进行重构。")]),t._v(" "),e("p",[t._v("在本实例中，由于CustomerDAO针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO的源代码。我们可以通过引入抽象数据转换类解决该问题，在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。根据里氏代换原则，程序运行时，具体数据转换类对象将替换DataConvertor类型的对象，程序不会出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件;如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。重构后的结构如图2所示:")]),t._v(" "),e("p",[e("img",{attrs:{src:s(531),alt:"alt 8"}}),t._v("\n图2重构后的结构图")]),t._v(" "),e("p",[t._v("在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。")])])}),[],!1,null,null,null);a.default=n.exports}}]);